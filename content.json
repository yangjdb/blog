[{"title":"nestjs 介绍（二）","date":"2018-01-08T13:25:20.000Z","path":"2018/01/08/nest-1/","text":"原理 设计思路nest 通篇围绕module这个概念展开，将原本以commonjs规范为标准的模块化构建工程，改造为节点式的图状依赖模块关系，其中的每一个module都是一个节点，以节点为入为出，将实现代码封装在链路中并串联起来，透明掉了原本需要开发定义的模块关系。 说简单点，就是把各实现代码模块之间的require交付给上层，而上层模块则根据业务需求划分，模块之间彼此互不依赖，模块内的业务单元以相同的结构化注入句柄（装饰器语法）把控制权反转给框架，从而做到统一的切面式处理。这种松散应用耦合的设计，强壮了骨架，透明了逻辑，灵活了业务。 这种设计思路大家是不是觉得有点眼熟呢，对，angular，还有vue（单文件组件），都是基于这样的思想，正是因为这样的解耦设计，使得应用层面可以放心的搭配模块或者组件而不必担心代码混乱，造成后期不好维护的局面。 废话不多说，还是举个栗子：假设我们有A,B,C,D 4个文件，依赖如下:12345#Aimport b from 'B';import c from 'C';...export a; 1234#Bimport c from 'C';...export b; 1234#Cimport d from 'D';...export c; 12#Dexport default d; 我们可以看到，对于C模块，有写法上有重复引入，虽然在node的执行环境里，只解释编码一次并常驻内存，但是我们知道。commonjs的规范，模块是副本传值，就意味着每引入一次，就会拷贝一份内存堆栈，虽然内存冗余问题并不大，但是对于有洁癖的程序员来说，这是不能忍的。 另外，我们无法规范每个开发人员的“引入习惯”，若没有一个好的架构设计支撑，协同开发出来的代码重复率有多高，看过整个项目的代码心里就会清楚。 nest意识到了这一点，所以通过泛型对象将module抽象出来，加上js动态编译（解释）的特点，灵活的重组了模块间的结构，改变了原来的耦合关系，与其说是框架，nest更像是脚手架，或者高阶模块构建工具。 我们来看一下，通过nest的改造，上边的代码依赖关系变成如下： moduleA imports: [moduleB, moduleC] components: [class A] exports: [instance of A] moduleB imports: [moduleC] components: [class B] exports: [instance of B] moduleC imports: [moduleD] components: [class C] exports: [instance of C] moduleD components: [class D] exprots: [instance of D] 每个module的结构都已约定，通过封装，可以作为独立的业务单元，之前以层级关系依赖变成了节点依赖的结构 再看每个类文件的内容： 123456#A: @Dependencies() export (b, c)=&gt;&#123; this.b = b; this.c = c; &#125; 12345#B: @Dependencies() export (c)=&gt;&#123; this.c = c; &#125; 12345#C: @Dependencies() export (d)=&gt;&#123; this.d = d; &#125; 12345#D: @Dependencies() export ()=&gt;&#123; return 'hello world'; &#125; 可以看到，每个文件已经不需要引入其他依赖模块，而变成了类导出，通过@Dependencies将所需要的模块注入，@这个标记我们先暂且放一边不管他，Dependencies句柄通过构造函数立即实例化并赋值给对象。而这就是流程控制反转，也叫依赖注入，即需要模块的时候已经提供好实例。有后台经验的同学看到这段代码应该不陌生吧，没错，就是受java的设计理念影响，nest参考ioc实现，遵循单一职责，依赖倒置原则，接口隔离原则，用链路传递依赖，用装饰代替定义。 这样做，其目的只有一个：隔离隔离业务关系，隔离开发盲区，让协同的负影响降到最小。 代码实现设计思路有了，接下来就是代码实现，上文中提到了Dependencies作为注入句柄，作用就是将模块提供的类实例化后注入相应的业务对象中，起到粘合剂的作用，说着这儿，想必很多同学已经看懂了，这不就是装饰器工厂么，对的，所以接下来我们先复习一下功课。 装饰器工厂是js设计模式之一，通过装饰类实现接口，以解决不同业务间适配问题。 同样，还是上代码：1234567891011121314151617181920212223242526272829Interface IAnimal&#123; speak()&#123;&#125;&#125;class Cat implements IAnimal&#123; speak()&#123; console.log('miaomiao'); &#125;&#125;class Dog implements IAnimal&#123; speak()&#123; console.log('wangwang'); &#125;&#125;class AnimalDecorate &#123; constructor(Animal)&#123; this.animal = new Animal; &#125; animalSpeak()&#123; this.animal.speak(); &#125;&#125;var animal_1 = new AnimalDecorate(Dog);var animal_2 = new AminalDecorate(Cat);animal_1.animalSpeak(); //wangwanganimal_2.animalSpeak(); //miaomiao 这是一段简单的装饰器伪代码，可以看到AnimalDecorate通过注入不同的类，产生不同的实例，但是最终执行的业务代码却是一样。那么复用到node的模块上面又该怎样？继续上代码1234567891011121314151617181920let moduleDecorator = function(module, target)&#123; ... //注入其他module提供的实例，包括组件，控制器，服务模块等 Object.defineProperty(target.prototype, 'module', module) ... //实例化本module return target;&#125;let moduleB = require('moduleB');let moduleC = require('moduleC');let moduleA = class moduleA &#123;&#125;;let controallerA = require('controallerA');let serviceA = require('serviceA');moduleA = moduleDecorator(&#123; modules: [moduleA, moduleB], controllers: [controallerA], components: [serviceA], exports: [serviceA]&#125;, moduleA);exports.moduleA = moduleA; 这段代码的作用只是将原有模块的类原型中添加其他实例，可以看出，我们只需要拿到类的句柄即可，装饰器moduleDecorator可以封装到核心库里。所以，上边代码可以优化一下12345678const core = require('core');...exports.moduleA = core.moduleDecorator(&#123; modules: [moduleA, moduleB], controllers: [controallerA], components: [serviceA], exports: [serviceA]&#125;); 另外，es6提供了装饰器的实现，使用Reflect，还可以这样写12345678910const core = require('core');...core(Reflect.decorate(moduleA, 'module', &#123; modules: [moduleA, moduleB], controllers: [controallerA], components: [serviceA], exports: [serviceA]&#125;));exports.moduleA = moduleA; 但是这样还是不够优雅，不可能我们每个模块都这样写，也没有达到代码分离的作用，还是有很高的侵入性。而且由于Reflect.decorate（数据元反射）还是处在实验室阶段，所以还是不推荐使用 那么是不是没有解决办法了呢，TypeScript表示呵呵哒，原生语法不支持，我可以造语法进行编译啊！！所以 @ 出现了 装饰器 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 以上便是TypeScript对于装饰器的定义，这里就不多做说明了，详情请移步：TypeScript装饰器我重点介绍一下nest搭配ts常用的三种装饰器：类声明，方法，参数。 类声明@module()：模块化依赖关系装饰123456@Module(&#123; modules: [ConfigModule, UtilModule], components: [CommonService], exports: [CommonService]&#125;)export class CommonModule &#123;&#125; @global()：全局对象/变量装饰12@global()export class GlobalModule &#123;&#125; @Component()：对象实例化装饰12@Component()export class CommonService &#123;&#125; @Dependency()：对象实例注入装饰1234567@Dependencies('Global', CommonService)export class UserService&#123; constructor(global, commonService) &#123; this.global = global; this.commonService = commonService; &#125;&#125; @Controller()：路由装饰，之所以把路由单独成一个装饰器，是因为所有的服务入口都是基于路由控制，每个业务模块单元自实现MVC的业务流程，都是对象的集合，需要用标识来区分哪些是路由，哪些是服务，判断也仅仅需要一行代码12@Controller('user')export class UserController&#123;&#125; @Middleware()：中间件装饰123456789@Middleware()export class LoggerMiddleware &#123; resolve(...args) &#123; return (req, res, next) =&gt; &#123; console.log(`[$&#123;args&#125;] Request...`); next(); &#125;; &#125;&#125; 方法@Post：http post请求装饰123@Post('/product/:id')async productFindOne() &#123;&#125; @Get：http get请求装饰123@Get('/login')async login() &#123;&#125; @Bind：http 参数注入装饰，适用于ES1234@Post('/product/:id')@Bind(Param(), Res())async productFindOne(params, res) &#123;&#125; 参数：参数装饰器，适用于TS@Params()@Req()@Res() 12345export class CatsController &#123; @Get() findAll(@Params() params, @Req() request, @Res() res) &#123; &#125;&#125; 小结装饰器工厂虽然不是新出的设计理念，但是在前端和node的应用场景却并不多，得益于java的控制反转，依赖注入实践参照，js使用装饰器完成了自身的反射机制，在框架层面上，angular补充了前端的空白，nest的出现补充了node的空白。这种核心层面向切面(AOP)，应用层面向对象(OOP)的编程方式，把node的模块依赖规则透明，使得项目结构耦合度很低，加上TS的预编译，模块复用率提高，拷贝成本大大降低，节省了内存消耗，这方面的性能测试报告后续会更新上来。 原理就先介绍到这里，欢迎大家指正。 推荐 Typescript中的装饰器原理 TypeScript 中的 Decorator &amp; 元数据反射：从小白到专家","tags":[{"name":"nestjs","slug":"nestjs","permalink":"https://yangjdb.github.io/blog/tags/nestjs/"}]},{"title":"nestjs 介绍（一）","date":"2018-01-07T12:01:52.000Z","path":"2018/01/07/nest/","text":"简介 关于nestjs，官方给出的说明是这样的： 一个强大的，渐进式的框架，用来建立高效可伸缩式的服务端应用；使用现代式的js语法，构建于TypeScript，并且向下兼容；采用面向对象编程思想，使用函数式编程； oh，shit！又是框架，相信前端的童鞋们看到框架这个词，心中都是神兽在奔腾吧。。。无妨，让我们先冷静一下，看看这个’框架’到底是什么来头 查了下gh，发现虽然nest构建至今不到半年，也才发布了10个版本，但是已然收获了3k+的star，口碑不错。nestjs :400+的commit，1 branch，10 release，19 contributors。 作者：Kamil Myśliwiec (波兰人，Scal.io高级软件工程师，nestjs创始人，angular顾问，react顾问，node.js顾问，TypeScript狂热爱好者) 膜拜大神…… 开源情况：MIT协议授权，已有谷歌，Uber，微软的一批支持者。 另外，月底 ngATL Conference Atlanta 的开发者大会上，nest工作室会讲解以下内容：• NestJS framework main concepts• The REST API building from scratch• WebSockets• Authentication using JSON Web Tokens• Automatic body shape verification• TypeORM• Auto-documenting API with Swagger module• Apollo GraphQL integration• Tips and best practices有条件的同学可以报名，希望到时候有资料可以学习。 好了，正片开始…… 惊艳 当我第一次看到nest的时候，就被它深深的吸引了，模块化的构建，优雅的依赖注入，松耦合的架构设计，编译式开发，易重构易维护，让我意识到node.js框架的统一已不再遥远。也正是因为想拥趸nest，想跟更多的前端同学布道，才有了写blog的初衷。 环境 node.js 6.11.0+(推荐LTS) ES6+babel TypeScript(推荐) 安装123$ git clone https://github.com/nestjs/typescript-starter.git project$ cd project$ npm install 启动1$ npm run start 编译1$ tsc 时间有限，第一篇介绍先写到这里，感兴趣的同学可以查阅官方文档 nest官方文档 后续将继续介绍nest框架原理，应用，优化以及实战等知识，欢迎大家拍砖~~如有疑问，可留言或提交issue。","tags":[{"name":"nestjs","slug":"nestjs","permalink":"https://yangjdb.github.io/blog/tags/nestjs/"}]},{"title":"序","date":"2018-01-07T03:00:25.000Z","path":"2018/01/07/hello/","text":"三杠三博客开的有点晚，过了2018，我也就成7年老猿了。时间不长也不短，看似漫漫，实则匆匆。蓦然一看，技术总归还是需要沉淀的，所以静下心来，抽丝剥茧。 我们之间流传着一个梗，那就是三杠三，心目当中’至高无上’的技术职级。不过现在已然沦为无节操的谈资，鲜有人知，也不必人知。以至于后来我经常对年轻的猿说，要想成为三杠三，首先你得学会不要脸。 =。= 至于我呢，已经不care这些了，浮生如梦，浮尘如空，都将泯没在这一行行的代码之中……","tags":[{"name":"随笔","slug":"随笔","permalink":"https://yangjdb.github.io/blog/tags/随笔/"}]}]